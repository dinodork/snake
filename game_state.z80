    ifndef game_state_z80
    define game_state_z80

; The Game consists of a grid, where each cell corresponds to an 8x8 pixel box on the
; visible screen. Each tile in this grid contains information about what goes on. It is
; either:
;
; - A direction, the direction that the snake exited this square.
; - Whether the square is occupied by a wall.
; - Whether the square contains food.
;
; There is also some additional information, such as the position of the head and the tail.
Game_height: EQU 24
Game_width: EQU 32

Game_size: EQU Game_height * Game_width
Game:
    DEFS Game_size
Game_tile_facing_up: EQU 0x00
Game_tile_facing_down: EQU 0x01
Game_tile_facing_left: EQU 0x02
Game_tile_facing_right: EQU 0x03
Game_tile_wall: EQU 0x04
Game_tile_food: EQU 0x05
Game_tile_empty: EQU 0xFF

; The head's on-screen x coordinate
Game_snake_head_x:
    DEFS 0x1
; The head's on-screen y coordinate
Game_snake_head_y:
    DEFS 0x1

; The tail's on-screen x coordinate
Game_snake_tail_x:
    DEFS 0x1

; The tail's on-screen y coordinate
Game_snake_tail_y:
    DEFS 0x1

Game_next_direction:
    DEFS 0x1

; The target length of the snake. The tail will not advance until this length
; is met.
Game_snake_target_length:
    DEFS 0x2
Game_snake_length:
    DEFS 0x2

Game_initial_snake_length: EQU 3
Game_head_start_x:  EQU Game_width / 2 + Game_initial_snake_length - 1
Game_head_start_y:  EQU Game_height / 2
Game_tail_start_x: EQU Game_width / 2
Game_tail_start_y: EQU Game_height / 2
Game_Phase_Running: EQU 0
Game_Phase_Game_Over: EQU 1
Game_Phase_Eating: EQU 2

Game_Phase:
    DEFS 1

Game_initialise:
    ; Clear the whole game
   	LD HL, Game
	LD DE, Game + 1
	LD BC, Game_size
	LD (HL), Game_tile_empty
	LDIR		; Copy this byte to the second, and so on

    ; Draw top wall
   	LD HL, Game + Game_width
	LD DE, Game + Game_width + 1
	LD BC, Game_width
	LD (HL), Game_tile_wall	; Set the first byte to 0
	LDIR		; Copy this byte to the second, and so on

    ; Draw snake
    LD IX, Game_snake_head_x
    LD (IX), Game_head_start_x

    LD IX, Game_snake_head_y
    LD (IX), Game_head_start_y

    LD IX, Game_snake_tail_x
    LD (IX), Game_tail_start_x

    LD IX, Game_snake_tail_y
    LD (IX), Game_tail_start_y

    LD IX, Game + Game_tail_start_y * Game_width + Game_tail_start_x
    LD (IX), Game_tile_facing_right
    LD (IX + 1), Game_tile_facing_right
    LD (IX + 2), Game_tile_facing_right

    LD HL, Game_snake_target_length
    LD (HL), 3
    LD HL, Game_snake_length
    LD (HL), 3

    LD IX, Game_next_direction
    LD (IX), Game_tile_facing_right
    RET

; HL: address of game tile in HL
; Returns the direction that the snake exited the tile in A.
Game_get_direction:
    LD A, (HL)
    RET

; Returns address of game tile in HL
;   H: Y position
;   L: X position
Game_get_address:
    ; Save the X value in DE
    LD E, L
    LD D, 0

    ; Make HL contain only the Y value
    LD L, H
    LD H, 0

    HL_X_32

    ; Add the X value back
    ADD HL, DE

    ; Add this to the start of Game
    LD DE, Game
    ADD HL, DE

    RET


; Checks for collision and updates game state accordingly.
;   H Snake head Y position
;   L Snake head X position
; Returns address of game state in IX

Detect_Collision:
    LD IX, Game_Phase
    LD A, L

    ; Right wall
    CP 31
    JP Z, Detect_Collision_Wall

    ; Left wall
    CP 0
    JP Z, Detect_Collision_Wall

    LD A, H

    ; Top wall
    CP 1
    JP Z, Detect_Collision_Wall

    ; Bottom wall
    CP 23
    JP Z, Detect_Collision_Wall

    CALL Game_get_address
    CALL Game_get_direction
    CP Game_tile_food
    JP Z, Detect_Collision_Food
    CP A, Game_tile_empty
    JP NZ, Detect_Collision_Wall

    LD (IX), Game_Phase_Running

    RET
Detect_Collision_Wall:
    LD (IX), Game_Phase_Game_Over
    RET

Detect_Collision_Food:
    LD IX, Game_snake_target_length
    INC (IX)
    INC (IX)
    INC (IX)

    CALL Place_Food

    LD IX, Game_Phase
    LD (IX), Game_Phase_Eating

    RET

    endif ; game_state_z80
