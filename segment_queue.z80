; The snake itself is implemented as queue of segments that lives inside a
; circular buffer. There can be at most 24 - 3 (top and bottom walls + score)
; times 32 - 2 (side walls) segments before game over, so that's the size of
; the buffer.
; Each segment is one byte, where
; Bit 0-3: The direction this segment is facing
; Bit 4-8: The direction the previous segment is found.
; For example, for this snake
;
;        -\
;         V
;
; The head is facing down, and the segment above it is found in the upwards
; direction. The first body segment is facing down, while the previous segment
; is found to the left. The tail is facing right, and has no segment following
; it, so it doesn't matter what we set it to.
;
; Hence the queue consists of
; {Facing_right, Facing_down | Follower_left, Facing_down | Follower_up}
;
; The head has the special case that its follower is in the opposite direction
; it's facing, while the tail has the special case that it has no follower,
; by definition.
Segment_Queue_buffer_size: EQU (Snake_head_size * (24 - 2) * (32 - 2))

Segment_Queue_buffer:
    DEFS Segment_Queue_buffer_size

; The index of the head in the segment queue buffer
Segment_Queue_head_index:
    DEFS 0x1

; The index of the tails in the segment queue buffer
Segment_Queue_tail_index:
    DEFS 0x1

; Initializes the queue. Initially, the queue consists of
; 0: tail
; 1: body segment
; 2: head
Segment_Queue_initialise:
	LD IX, Segment_Queue_head_index
    LD (IX), 2

	LD IX, Segment_Queue_tail_index
    LD (IX), 0

    RET