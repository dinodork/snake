    ifndef graphics_z80
    define graphics_z80

; The game's graphics is all in this file

Graphics_play_area_size: EQU (32 - 2) * (24 - 3)

; Lookup table for body segments. The tile to choose for a body segment depends
; upon:
; 1) The previous tile's direction
; 2) The current tile's direction
; To get the correct tile index, take the previous tile's direction and use
; that value as the row, then use the current tile's direction and use that
; as the column. Some combinations make no sense, e.g. Up+Down, and these
; slots contain a -1.
Body_segments:
; Turning -> Up Down Left Right   While going
    BYTE     12,  -1,  16,   20 ; Up
    BYTE     -1,  12,  22,   18 ; Down
    BYTE     18,  20,  14,   -1 ; Left
    BYTE     22,  16,  -1,   14 ; Right

; Draws a frame (bitmap + attribute) of the snake.
;   H: Y position
;   L: X position
;   A: Tile number
Draw_Snake_Tile:
    PUSH HL
    PUSH AF
    CALL Get_Char_Address
    LD DE, Frames_1
    POP AF
    CALL Print_Char

    POP HL
    CALL Get_Attr_Address
    LD A, Snake_ink
    CALL Set_Ink

    RET

; Draws food's stalk at the position.
; H = Y character position
; L = X character position
Draw_Stalk:
    PUSH HL
    CALL Get_Char_Address
    LD IY, Frames_apple_stalk
    CALL Print_UDG8
    POP HL
    CALL Get_Attr_Address
    LD A, Apple_stalk_ink
    CALL Set_Ink

    RET

Draw_Apple:
    PUSH HL
    CALL Get_Char_Address
    LD IY, Frames_apple
    CALL Print_UDG8
    POP HL
    CALL Get_Attr_Address
    LD A, Apple_ink
    CALL Set_Ink
    RET

; Draws the head
;   A: Direction of the head.
Draw_Head:
    LD HL, (Game_snake_head_x) ; H := Y position, L := X position
    CALL Game_get_address
    CALL Game_get_direction

    PUSH AF
    LD HL, (Game_snake_head_x)
    CALL Get_Char_Address
    POP AF

    PUSH AF
    ; We would normally add an offset to the first head frame here, but since
    ; it starts on position 0, we don't need to.

    LD HL, (Game_snake_head_x) ; H := Y position, L := X position
    CALL Draw_Snake_Tile
    POP AF

    RET

; A: Current direction of the segment.
; H: Current body segment Y position
; L: Current body segment X position
Draw_snake_body_segment:
    PUSH HL
    CALL Game_get_address
    CALL Game_get_direction
    LD B, A

    ; A := B * 4
    LD A, 0
Draw_snake_body_segment_loop:
    ADD A, 4
    DJNZ Draw_snake_body_segment_loop
    LD C, A

    LD A, (Game_next_direction)
    ADD A, C

    ; Index into the lookup table, it's one-dimensional at this point.
    LD D, 0
    LD E, A
    LD HL, Body_segments
    ADD HL, DE

    LD A, (HL)

    POP HL

    PUSH AF
    LD A, H
    XOR L
    AND A, 1
    LD B, A
    POP AF
    ADD A, B

    CALL Draw_Snake_Tile

    RET

; Draws the snake's tail. Takes no arguments.
; The snake wags its tail as it slithers across the screen, alternating between
; left and right. The frames are organised to that even frames point left and odd
; frames right. We bake the wagging into the formula for indexing into the
; frames, arriving at:
;
;     index := direction + ((Y_pos xor X_pos) mod 2)
;
; We choose xor because it changes every time either operand changes.
Draw_Tail:

    ; Get the current tile's direction and push it on the stack.
    LD HL, (Game_snake_tail_x) ; H := Y position, L := X position
    LD A, H
    XOR L
    AND A, 1
    LD B, A

    CALL Game_get_address
    CALL Game_get_direction

    PUSH AF
    LD HL, (Game_snake_tail_x) ; As above
    CALL Get_Char_Address
    POP AF

    RLA ; A := A * 2
    ADD A, B
    ADD A, Tile_snake_tail_start

    LD HL, (Game_snake_tail_x) ; As above
    CALL Draw_Snake_Tile

    RET

        endif ; graphics_z80
